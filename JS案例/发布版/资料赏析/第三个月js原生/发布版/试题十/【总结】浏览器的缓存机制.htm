<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    
    <title>【总结】浏览器的缓存机制</title>
    <meta name="keywords" content="" />
    <meta name="description" content="" />

    <link href="http://static.guojl.com/css/default.css" rel="stylesheet" type="text/css" media="screen" />
    
    <link type="text/css" rel="stylesheet" href="http://static.guojl.com/js/syntaxhighligher/styles/shCoreDefault.css"/>
    <link type="text/css" rel="stylesheet" href="http://static.guojl.com/js/syntaxhighligher/styles/shThemeDefault.css"/>

<script type="text/javascript" src="http://static.guojl.com/js/jquery-1.4.1.min.js"></script>
    


</head>
<body>
<!-- start header -->
<div id="header">
    <div id="logo">
       <h1><a href="/">guojl's blog</a></h1>

            <form action="/s/" method="get" class="search">
                <input title="搜索" type="image" onclick="if(search.value==search.defaultValue) return false;"  value="search" style="height: 30px; width: 30px; float: right;" src="http://static.guojl.com/images/search.png">
                <input style="width: 200px;color: #808080;float: right;" name="search" id="search" onclick="if(this.value==this.defaultValue) this.select()" value="输入关键字" >

            </form>

        <!--<h2><a href="http://www.freecsstemplates.org/">By Free CSS Templates</a></h2>-->
    </div>
    <div id="menu">
        <ul>
            <li class="active"><a href="/" accesskey="1" title="">首页</a></li>
            <!--<li><a href="#" accesskey="2" title="">Photos</a></li>
            <li><a href="#" accesskey="3" title="">About</a></li>
            <li><a href="#" accesskey="4" title="">Contact</a></li>-->
        </ul>
    </div>
</div>
<!-- end header -->
<!-- start page -->
<div id="page">

        <!-- start content -->
        <div  class="content">
                    <h1 class="title">【总结】浏览器的缓存机制</h1>
                    <p class="byline">
                        <small>
                            
                               来源：<a target="_blank" href="http://www.guojl.com/go?url=http://blog.csdn.net/yzhou86/article/details/6864189">http://blog.csdn.net/yzhou86/article/details/6864189</a>
                            
                        </small></p>
                    <div class="maincontent">
                        <h2><span style="color: #cc0000;">【文章一：&nbsp;<strong>iefirefox Chrome Safari缓存机制</strong>&nbsp;】</span></h2>
<table style="width: 757px;" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;</p>
<p align="left"><strong>Cache-Control</strong></p>
<p align="left">Cache-Control&nbsp;是最重要的规则。这个字段用于指定所有缓存机制在整个请求 / 响应链中必须服从的指令。这些指令指定用于阻止缓存对请求或响应造成不利干扰的行为。这些指令通常覆盖默认缓存算法。缓存指令是单向的，即请求中存在一个 指令并不意味着响应中将存在同一个指令。</p>
<p align="left">cache-control&nbsp;定义是：Cache-Control = &ldquo;Cache-Control&rdquo; &ldquo;:&rdquo; cache-directive 。表1 展示了适用的值。</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;<strong>Cache-directive</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>说明</strong>&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;public&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;所有内容都将被缓存&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;private&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;内容只缓存到私有缓存中&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;no-cache&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;所有内容都不会被缓存&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;no-store&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;所有内容都不会被缓存到缓存或 Internet 临时文件中&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;must-revalidation/proxy-revalidation&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;如果缓存的内容失效，请求必须发送到服务器 / 代理以进行重新验证&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;max-age=xxx (xxx is numeric)&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;缓存的内容将在 xxx 秒后失效 , 这个选项只在&nbsp;&nbsp;HTTP 1.1 可用 , 并如果和&nbsp;&nbsp;Last-Modified 一起使用时 , 优先级较高&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="2">
<p align="left">&nbsp;&nbsp;表 1. 常用 cache-directive 值&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;</p>
<p align="left">表2 表明在不同的情形下，浏览器是将请求重新发送到服务器还是使用缓存的内容。</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;<strong>Cache-directive</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>打开一个新的浏览器窗口</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>在原窗口中单击 Enter 按钮</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>刷新</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>单击 Back 按钮</strong>&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;public&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;private&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;no-cache/no-store&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;must-revalidation/proxy-revalidation&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;max-age=xxx (xxx is numeric)&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;在 xxx 秒后，浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;在 xxx 秒后，浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;在 xxx 秒后，浏览器重新发送请求到服务器&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;表 2. 对 cache-directive 值的浏览器响应&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">Cache-Control&nbsp;是关于浏览器缓存的最重要的设置，因为它覆盖其他设置，比如 Expires 和 Last-Modified 。另外，由于浏览器的行为基本相同，这个属性是处理跨浏览器缓存问题的最有效的方法。</p>
<p align="left"><strong>失效</strong></p>
<p align="left">Expires&nbsp;头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。失效的缓存条目通常不会被缓存（无论是 代理缓存还是用户代理缓存）返回，除非首先通过原始服务器（或者拥有该实体的最新副本的中介缓存）验证。（注意： cache-control max-age 和 s-maxage 将覆盖 Expires 头部。）</p>
<p align="left">Expires&nbsp;字段接收以下格式的值： &ldquo;Expires: Sun, 08 Nov2009 03:37:26 GMT&rdquo; 。如果查看内容时的日期在给定的日期之前，则认为该内容没有失效并从缓存中提取出来。反之，则认为该内容失效，缓存将采取一些措施。表 3-6 表明针对不同用户操作的不同浏览器的行为。</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Firefox 3.5</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>IE 8</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Chrome 3</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Safari 4</strong>&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容没有失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;表 3. 当用户打开一个新的浏览器窗口时的失效操作&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;&nbsp;</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Firefox 3.5</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>IE 8</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Chrome 3</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Safari 4</strong>&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容没有失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 304&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 304&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;表 4. 当用户在原始浏览器窗口中单击 Enter 按钮时的失效操作&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;&nbsp;</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Firefox 3.5</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>IE 8</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Chrome 3</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Safari 4</strong>&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容没有失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 304&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 304&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 304&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 304&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;表 5. 当用户按 F5 键刷新页面时的失效操作&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;&nbsp;</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Firefox 3.5</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>IE 8</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Chrome 3</strong>&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;<strong>Safari 4</strong>&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容没有失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;内容失效&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;浏览器重新发送请求到服务器。返回代码是 200&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;表 6. 当用户单击 Back 或&nbsp;&nbsp;Forward 按钮时的失效操作&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">注意：所有浏览器都假定为使用默认设置运行。</p>
<p align="left"><strong>Last-Modified/E-Tag</strong></p>
<p align="left">Last-Modified&nbsp;实体头部字段值通常用作一个缓存验证器。简单来说，如果实体值在 Last-Modified 值之后没有被更改，则认为该缓存条目有效。 ETag 响应头部字段值是一个实体标记，它提供一个 &ldquo; 不透明 &rdquo; 的缓存验证器。这可能在以下几种情况下提供更可靠的验证：不方便存储修改日期； HTTP 日期值的 one-second 解决方案不够用；或者原始服务器希望避免由于使用修改日期而导致的某些冲突。</p>
<p align="left">不同的浏览器有不同的配置行为。表 7-10 表明针对不同用户操作的不同浏览器的行为。</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Firefox 3.5</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>IE 8</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Chrome 3</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Safari 4</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来没有被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来已经被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;</p>
<p align="left">表 7. 当用户打开一个新的浏览器窗口时的 Last-Modified E-Tag 操作</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;&nbsp;</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Firefox 3.5</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>IE 8</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Chrome 3</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Safari 4</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来没有被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来已经被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面&nbsp;&nbsp;</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;</p>
<p align="left">表 8. 当用户在原始浏览器窗口中单击 Enter 按钮时的 Last-Modified E-Tag 操作</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;&nbsp;</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Firefox 3.5</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>IE 8</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Chrome 3</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Safari 4</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来没有被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 304</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来已经被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;</p>
<p align="left">表 9. 当用户按 F5 键刷新页面时的 Last-Modified E-Tag 操作</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;&nbsp;</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Firefox 3.5</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>IE 8</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Chrome 3</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Safari 4</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来没有被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">内容自上次访问以来已经被修改</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;</p>
<p align="left">表 10. 没有缓存设置且用户单击 Back 或 Forward 按钮</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">注意：所有浏览器都假定使用默认设置运行。</p>
<p align="left">不进行任何缓存相关设置</p>
<p align="left">如果您不定义任何缓存相关设置，则不同的浏览器有不同的行为。有时，同一个浏览器在相同的情形下每次运行时的行为都是不同的。情况可能很复杂。另外，有些不该缓存的内容如果被缓存，将会导致安全问题。<br /> 不同的浏览器有不同的行为。表 11 展示了不同的浏览器行为。</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Firefox 3.5</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>IE 8</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Chrome 3</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="center"><strong>Safari 4</strong></p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">打开一个新页面</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">在原始窗口中单击 Enter 按钮</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面。</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">按 F5 键刷新</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">单击 Back 或 Forward 按钮&nbsp;&nbsp;</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面。</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器呈现来自缓存的页面。</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">浏览器重新发送请求到服务器。返回代码是 200</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td colspan="5">
<p align="left">&nbsp;&nbsp;</p>
<p align="left">表 11. 没有缓存设置且用户打开一个新的浏览器窗口</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p align="left">注意：所有浏览器都假定使用默认设置运行。</p>
<p align="left">最后 , 概括下关键的结论 :</p>
<table style="width: 740px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">打开新窗口</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">如果指定 cache-control 的值为 private 、 no-cache 、 must-revalidate, 那么打开新窗口访问时都会重新访问服务器。而如果指定了 max-age 值 , 那么在此值内的时间里就不会重新访问服务器 , 例如： Cache-control: max-age=5 表示当访问此网页后的 5 秒内再次访问不会去服务器 .</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">在地址栏回车</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">如果值为 private 或 must-revalidate, 则只有第一次访问时会访问服务器 , 以后就不再访问。如果值为 no-cache, 那么每次都会访问。如果值为 max-age, 则在过期之前不会重复访问。</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">按后退按扭</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">如果值为 private 、 must-revalidate 、 max-age, 则不会重访问 , 而如果为 no-cache, 则每次都重复访问 .</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">按刷新按扭</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
<td>
<p align="left">&nbsp;&nbsp;</p>
<p align="left">无论为何值 , 都会重复访问 .</p>
<p align="left">&nbsp;&nbsp;</p>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p align="left">&nbsp;</p>
<h2><a name="t1"></a><span style="color: #cc0000;">【文章2&nbsp;<strong>DOMContentLoaded与 onload的区别</strong>】</span></h2>
<p align="left">1.DOMContentLoaded</p>
<p align="left">DOMContentLoaded是FF,Opera 9的特有的Event, 当所有DOM解析完以后会触发这个事件。</p>
<p align="left">&nbsp;jquery的ready(示例:$("selector).ready(function(){})),MT的onDomReady</p>
<p align="left">&nbsp;IE下是scrollleft事件可以时就表示DomcontentLoaded: var temp= document.createElement('div');temp.doScroll('left');</p>
<p align="left">&nbsp;Fired on a Window object when a document's DOMcontent is finished loading, but unlike "load", does not wait untilall images are loaded. Used for example by GreaseMonkey to sneak in to alterpages before they are displayed.</p>
<p align="left">This event, as many others on this page, is dispatched to"trusted" targets only; for example, it is not dispatched to thecontent of the main browser object in Firefox, even if it comes from a chrome:/URI.</p>
<p align="left">&nbsp;</p>
<p align="left">2.Onload</p>
<p align="left">&nbsp;onload要等到所有页面元素加载完成才会触发, 包括页面上image、flash、iframe等内容都加载完毕才会执行。</p>
<p align="left">&nbsp;</p>
<h2><a name="t2"></a><span style="color: #cc0000;">【文章3&nbsp;<strong>HTML页面加载和解析流程</strong>】</span></h2>
<p align="left">1.用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</p>
<p align="left"><br /> 2.浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；</p>
<p align="left">&nbsp;</p>
<p align="left">3.浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</p>
<p align="left"><br /> 4.浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</p>
<p align="left"><br /> 5.浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</p>
<p align="left"><br /> 6.服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</p>
<p align="left"><br /> 7.浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它；</p>
<p align="left"><br /> 8.Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞&nbsp;（style.display=&rdquo;none&rdquo;）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</p>
<p align="left"><br /> 9.终于等到了＜/html＞的到来，浏览器泪流满面&hellip;&hellip;</p>
<p align="left"><br /> 10.等等，还没完，用户点了一下界面中的&ldquo;换肤&rdquo;按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；</p>
<p align="left"><br /> 11.浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，&ldquo;大伙儿收拾收拾行李，咱得重新来过&hellip;&hellip;&rdquo;，浏览器向服务器请求了新的CSS文件，重新渲染页面。</p>
<p align="left">&nbsp;</p>
<h2><a name="t3"></a><span style="color: #cc0000;">【文章4&nbsp;<strong>HTTP请求中浏览器的缓存机制</strong>】</span></h2>
<p align="left"><strong>【流程】</strong></p>
<p align="left">当资源第一次被访问的时候，HTTP头部如下</p>
<p align="left">(Request-Line)&nbsp; GET /a.html HTTP/1.1</p>
<p align="left">Host&nbsp;&nbsp;&nbsp; 127.0.0.1</p>
<p align="left">User-Agent&nbsp; Mozilla/5.0 (X11; U; Linux i686;zh-CN;rv:1.9.0.15) Gecko/2009102815 Ubuntu/9.04 (jaunty) Firefox/3.0.15</p>
<p align="left">Accept&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</p>
<p align="left">Accept-Language&nbsp;&nbsp;&nbsp;&nbsp; zh-cn,zh;q=0.5</p>
<p align="left">Accept-Encoding&nbsp;&nbsp;&nbsp;&nbsp; gzip,deflate</p>
<p align="left">Accept-Charset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gb2312,utf-8;q=0.7,;q=0.7</p>
<p align="left">Keep-Alive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;300</p>
<p align="left">Connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keep-alive</p>
<p align="left">HTTP返回头部如下</p>
<p align="left">(Status-Line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP/1.1 200 OK</p>
<p align="left">Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thu, 26 Nov 2009 13:50:54 GMT</p>
<p align="left">Server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apache/2.2.11 (Unix) PHP/5.2.9</p>
<p align="left">Last-Modified&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thu, 26Nov 2009 13:50:19 GMT</p>
<p align="left">Etag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"8fb8b-14-4794674acdcc0"</p>
<p align="left">Accept-Ranges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytes</p>
<p align="left">Content-Length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20</p>
<p align="left">Keep-Alive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout=5, max=100</p>
<p align="left">Connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Keep-Alive</p>
<p align="left">Content-Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text/html</p>
<p align="left">当资源第一次被访问的时候，http返回200的状态码，并在头部携带上当前资源的一些描述信息，如</p>
<p align="left">Last-Modified&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 指示最后修改的时间</p>
<p align="left">Etag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 指示资源的状态唯一标识</p>
<p align="left">Expires&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 指示资源在浏览器缓存中的过期时间</p>
<p align="left">接着浏览器会将文件缓存到Cache目录下，并同时保存文件的上述信息</p>
<p align="left">当第二次请求该文件时，浏览器会先检查Cache目录下是否含有该文件，如果有，并且还没到Expires设置的时间，即文件还没有过期，那么此时浏览器将直接从Cache目录中读取文件，而不再发送请求</p>
<p align="left">如果文件此时已经过期，则浏览器会发送一次HTTP请求到WebServer，并在头部携带上当前文件的如下信息</p>
<p align="left">If-Modified-Since&nbsp;&nbsp; Thu, 26 Nov 2009 13:50:19GMT</p>
<p align="left">If-None-Match&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"8fb8b-14-4794674acdcc0"</p>
<p align="left">即把上一次修改的时间，以及上一次请求返回的Etag值一起发送给服务器。服务器在接收到这个请求的时候，先解析Header里头的信息，然后校验该头部信息。</p>
<p align="left">如果该文件从上次时间到现在都没有过修改或者Etag信息没有变化，则服务端将直接返回一个304的状态，而不再返回文件资源，状态头部如下</p>
<p align="left">(Status-Line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP/1.1 304 Not Modified</p>
<p align="left">Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thu, 26 Nov 2009 14:09:07 GMT</p>
<p align="left">Server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apache/2.2.11 (Unix) PHP/5.2.9</p>
<p align="left">Connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Keep-Alive</p>
<p align="left">Keep-Alive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout=5, max=100</p>
<p align="left">Etag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"8fb8b-14-4794674acdcc0"</p>
<p align="left">这样，就能够很大程度上减少网络带宽以及提升用户的浏览器体验。</p>
<p align="left">当然，如果服务器经过匹配发现文件修改过了，就会将文件资源返回，并带上新文件状态信息。</p>
<p align="left">&nbsp;</p>
<p align="left"><strong>【基本字段】</strong></p>
<p align="left"><strong>Pragma</strong></p>
<p align="left">Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同。</p>
<p align="left"><strong>Expires</strong></p>
<p align="left">文件在本地缓存的过期时间，如果浏览器发现缓存中的文件没有过期，则不发送请求（有例外，后面介绍）</p>
<p align="left"><strong>Cache-Control</strong></p>
<p align="left">Cache -Control指定请求和响应遵循的缓存机制。</p>
<p align="left">在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括</p>
<p align="left">no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached</p>
<p align="left">响应消息中的指令包括</p>
<p align="left">public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age</p>
<p align="left">各个消息中的指令含义如下：</p>
<p align="left">1.&nbsp;Public指示响应可被任何缓存区缓存。</p>
<p align="left">2.&nbsp;Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</p>
<p align="left">3.&nbsp;no-cache指示请求或响应消息不能缓存</p>
<p align="left">4.&nbsp;no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</p>
<p align="left">5.&nbsp;max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</p>
<p align="left">6.&nbsp;min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</p>
<p align="left">7.&nbsp;max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>
<p align="left"><strong>Etag/If-None-Match</strong></p>
<p align="left">一对验证文件实体的标记 &ldquo;Entity Tag&rdquo;的响应/请求头Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的</p>
<p align="left"><strong>Last-Modified/If-Modified-Since</strong></p>
<p align="left">一对验证文件的修改时间的响应/请求头</p>
<p align="left">Expires、Cache-Control、Last-Modified、ETag是RFC2616（HTTP/1.1）协议中和网页缓存相关的几个字段。</p>
<p align="left">前两个用来控制缓存的失效日期，浏览器可通过它来判定，需不需要发出HTTP请求；</p>
<p align="left">后两个用来验证网页的有效性，服务器端利用它来验证这个文件是否需要重新返回</p>
<p align="left"><strong>Last-ModifiedVS Etag</strong></p>
<p align="left">既然有了Last-Modified，为什么还要用ETag字段呢？因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确。因此，HTTP/1.1利用Entity Tag头提供了更加严格的验证。</p>
<p align="left">&nbsp;</p>
<p align="left"><strong>【不同的情况】</strong></p>
<p align="left">上面描述的是一个普通的浏览器缓存状态，在实际应用中，如页面跳转（点击页面链接跳转，window.open，在地址栏敲回车，刷新页面）等操作，会有一些区别</p>
<p align="left"><strong>普通页面跳转</strong></p>
<p align="left">普通页面跳转包括链接点击跳转，用js脚本打开新页面（window.open）</p>
<p align="left">无缓存情况下，请求会返回所有资源结果</p>
<p align="left">设置Expires并且未过期时，浏览器将不会发出http请求</p>
<p align="left">如果Expires过期，则会发送相应请求，并附带上Last-Modifed等信息，供服务器校验</p>
<p align="left"><strong>页面刷新(F5)</strong></p>
<p align="left">这种情况一下，一般会看到很多304的请求，就是说即便资源设置了Expires且未过期，浏览器也会发送相应请求</p>
<p align="left">IE和FF稍有区别</p>
<p align="left">IE:</p>
<p align="left">If-Modified-Since&nbsp;&nbsp; Wed, 18 Nov 2009 15:54:52GMT</p>
<p align="left">If-None-Match&nbsp;&nbsp; "2360492659"</p>
<p align="left">Pragma: no-cache&nbsp;&nbsp;&nbsp; // 禁止缓存</p>
<p align="left">FF:</p>
<p align="left">If-Modified-Since&nbsp;&nbsp; Wed, 18 Nov 2009 15:54:52GMT</p>
<p align="left">If-None-Match&nbsp;&nbsp; "2360492659"</p>
<p align="left">Cache-Control&nbsp;&nbsp; max-age=0&nbsp;&nbsp;// 文件立即过期</p>
<p align="left"><strong>强制刷新(Ctrl+F5)</strong></p>
<p align="left">效果和无缓存时候一致，返回200的结果</p>
<p align="left"><strong>一些特殊的资源</strong></p>
<p align="left"><strong>IFRAME</strong></p>
<p align="left">&nbsp;</p>
<p>我有一个主页面包含iframe框架，iframe加载一个ajax操作json的页面。当第一次打开这个主页面的时候，iframe中页面读取 json数据是最新的，当数据库中修改了数据再刷新主页面的时候，iframe中页面的数据没有从数据库中取得最新的数据。这类问题，在FF中的解决方法 可以参考<a style="color: #666666; text-decoration: none;" href="http://www.experts-exchange.com/Web_Development/Web_Languages-Standards/HTML/Q_22051441.html" target="_blank">How to get iframe not to cache in IE</a>这篇文章，即在页面的head部分加上以下语句:</p>
<p><span style="color: #000080;">&lt;META http-equiv="Expires" content="Mon, 26 Jul 1997 05:00:00 GMT"&gt;<br /> &lt;META http-equiv="Last-Modified" content="Sat, 10 Nov 1997 09:08:07 GMT"&gt;<br /> &lt;META http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"&gt;<br /> &lt;META http-equiv="Pragma" content="no-cache"&gt;</span></p>
<p>但在IE中无效。<a style="color: #666666; text-decoration: none;" href="http://www.dynamicdrive.com/forums/archive/index.php/t-9974.html" target="_blank">IE中解决iFrame缓存问题</a>的方法有两种：</p>
<p>(1) 每次主页面刷新时随机更换iframe的name;</p>
<p>(2) 每次主页面刷新时在iframe的src路径页面赋予一个随机get参数，例如：</p>
<p>&lt;iframe src="http://www.example.com/thepage.html" name="aframe"&gt;&lt;/iframe&gt;<br /> &lt;script type="text/javascript"&gt;<br /> &nbsp;&nbsp;&nbsp; document.frames['aframe'].location.href += (document.frames['aframe'].location.href.indexOf("?") != -1 ? "?" : "&amp;") + (new Date()).getTime();<br /> &lt;/script&gt;</p>
<p align="left"><strong>FLASH</strong></p>
<p align="left">&nbsp;</p>
<p>使用以下的方法，使SWF文件强制不从浏览器读本地的缓存。或强制其SWF文件每次都去 读取最新的媒体文件</p>
<p>确保每次都读取最新的SWF文件。</p>
<p>1：使用"Expires"标头 这是在HTML文件中告诉浏览器不读取本地缓存<br /> 在&lt;head&gt; &lt;/head&gt; 中间加以下代码<br /> <span class="code" style="font-family: Verdana,'Courier New',Courier,mono; font-size: 12px; line-height: 18px; color: #000000; background-color: #ddedfb; width: 480px; display: block; border-width: 1px; border-color: #0099cc; border-style: solid; padding: 5px; margin: 5px;">&lt;!-- BEGIN INSERT --&gt;&nbsp;<br /> &lt;META HTTP-EQUIV="Expires" CONTENT="Mon, 04 Dec 1999 21:29:02 GMT"&gt;<br /> &lt;!-- END INSERT --&gt;</span><br /> 这样的话，每次访问这个文件都会告诉浏览器其缓存版本过期，将重新从服务器端读取最新的文件</p>
<p>2：直接告诉浏览器根本就没有缓存<br /> 在包含SWF文件的HTML页面里的&lt;/body&gt;插入：<br /> <span class="code" style="font-family: Verdana,'Courier New',Courier,mono; font-size: 12px; line-height: 18px; color: #000000; background-color: #ddedfb; width: 480px; display: block; border-width: 1px; border-color: #0099cc; border-style: solid; padding: 5px; margin: 5px;">&lt;!-- BEGIN INSERT --&gt;<br /> <br /> &lt;HEAD&gt;<br /> &lt;META HTTP-EQUIV="PRAGMA" CONTENT="NO-CACHE"&gt;<br /> &lt;/HEAD&gt;<br /> <br /> &lt;!-- END INSERT --&gt;</span><br /> 没有Cache标头 不支持IE5版本，所以微软建议使用带Cacahe控制标头</p>
<p>3：当在HTML页面间连接跳转时<br /> 在点击超连接时将强制其从服务器上下载最新文档而不是从本地缓存中浏览<br /> <br /> 例如：<br /> <span class="code" style="font-family: Verdana,'Courier New',Courier,mono; font-size: 12px; line-height: 18px; color: #000000; background-color: #ddedfb; width: 480px; display: block; border-width: 1px; border-color: #0099cc; border-style: solid; padding: 5px; margin: 5px;">&lt;A HREF="stockPrices.htm?1"&gt;Current stock prices&lt;/A&gt;</span><br /> <br /> 以上方法将阻止读取本地缓存</p>
<p>如何阻止从缓存中读取加载变量<br /> <br /> 问题：<br /> 当从外部数据源加载数据时，有时浏览器将数据存贮在本地缓存中，这样就导致<br /> 在调用loadVariables方法加载数据时会从本地缓存中读取数据而代替从原始数据<br /> 读取的信息。</p>
<p>解决：<br /> 为确保flash加载的是最新的变量，附加一个随机数变量，这样就可以原始档中加载最新的数据</p>
<p>例如：<br /> 方法一：<br /> <span class="code" style="font-family: Verdana,'Courier New',Courier,mono; font-size: 12px; line-height: 18px; color: #000000; background-color: #ddedfb; width: 480px; display: block; border-width: 1px; border-color: #0099cc; border-style: solid; padding: 5px; margin: 5px;">loadVariables("mypage.asp?nocache=" + random(65000), 0, "POST");</span></p>
<p>方法二：<br /> <span class="code" style="font-family: Verdana,'Courier New',Courier,mono; font-size: 12px; line-height: 18px; color: #000000; background-color: #ddedfb; width: 480px; display: block; border-width: 1px; border-color: #0099cc; border-style: solid; padding: 5px; margin: 5px;">loadVariables("mypage.asp?nocache=" + getTimer(), 0, "POST");</span></p>
<p>这样确保每次加载的数据是最新的.</p>
<p>&nbsp;</p>
<p align="left"><strong><br /> </strong></p>
<p align="left"><strong>异步获取的数据(AJAX)</strong></p>
<p align="left">&nbsp;</p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;">项目有时要用一些Ajax的效果，因为比较简单，也就没有去用什么Ajax.net之类的东西，手写代码也就实现了。、</p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;">第二天，有人向我报告错误；说是只有第一次读取的值正常，后面的值都不正常；我调试了一下 ，确实有这样的问题，查出是因为AJAX缓存的问题：解决办法有如下几种:</p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #008080;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、在服务端加 header("Cache-Control: no-cache, must-revalidate");(如php中)</span></p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #008080;">　　2、</span><span style="color: #ff0000;">在ajax发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0");</span></p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #008080;">　　3、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache");</span></p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #008080;">　　4、在 Ajax 的 URL 参数后加上 "?fresh=" + Math.random(); //当然这里参数 fresh 可以任意取了</span></p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #008080;">　　5、</span><span style="color: #ff0000;">第五种方法和第四种类似，在 URL 参数后加上 "?timestamp=" + new Date().getTime();</span></p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #008080;">　　6、用POST替代GET：不推荐</span></p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;">&nbsp;</p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;">1、加个随机数<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlHttp.open("GET", "ajax.asp?now=" + new Date().getTime(), true);<br /> <br /> 2、在要异步获取的asp页面中写一段禁止缓存的代码：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Buffer =True<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.ExpiresAbsolute =Now() - 1<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Expires=0<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.CacheControl="no-cache"</p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;">3、在ajax发送请求前加上xmlHTTP.setRequestHeader("If-Modified-Since","0");可以禁止缓存<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlHTTP.open("get", URL, true);&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlHTTP.onreadystatechange = callHTML;&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlHTTP.setRequestHeader("If-Modified-Since","0");&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xmlHTTP.send();</p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #ff0000;">另一个作者写到:</span></p>
<div class="bvMsg" style="padding: 0px; margin: 0px;">
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;">AJAX的缓存是由浏览器维持的，对于发向服务器的某个url，<span style="color: #ff0000;">ajax仅在第一次请求时与服务器交互信息，之后的请求中，ajax不再向服务器提交请求，而是直接从缓存中提取数据。<br /> </span><br /> 有些情况下，我们需要每一次都从服务器得到更新后数据。<span style="color: #ff0000;">思路是让每次请求的url都不同，而又不影响正常应用：在url之后加入随机内容。<br /> </span>e.g.<br /> url=url+"&amp;"+Math.random();<br /> <br /> Key points:<br /> 1<span style="color: #ff0000;">.每次请求的url都不一样（ajax的缓存便不起作用）</span><br /> 2.不影响正常应用（最基本的）<br /> <br /> ----------------<br /> 方法二：（未经证实）<br /> 在JSP中禁止缓存<br /> response.addHeader("Cache-Control", "no-cache");<br /> response.addHeader("Expires", "Thu, 01 Jan 1970 00:00:01 GMT");&nbsp;<br /> <br /> HTTP:<br /> &lt;META HTTP-EQUIV="pragma" CONTENT="no-cache"&gt;<br /> &lt;META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"&gt;<br /> &lt;META HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT"&gt;<br /> &lt;META HTTP-EQUIV="expires" CONTENT="0"&gt;</p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;"><span style="color: #ff0000;">另一个作者写到:</span></p>
<p style="margin-top: 5px; margin-right: auto; margin-bottom: 5px; margin-left: auto; padding-top: 0px; padding-bottom: 0px; text-indent: 0px;">我们都知道，ajax能提高页面载入的速度的主要原因是通过ajax减少了重复数据的载入，真正做到按需获取，既然如此，我们在写ajax程序的时候不妨 送佛送到西，在客户端再做一次缓存,进一步提高数据载入速度。那就是在载入数据的同时将数据缓存在浏览器内存中，一旦数据被载入，只要页面未刷新，该数据 就永远的缓存在内存中，当用户再次查看该数据时，则不需要从服务器上去获取数据，极大的降低了服务器的负载和提高了用户的体验。</p>
</div>
<p>&nbsp;</p>
<p align="left">&nbsp;</p>
<h3><a name="t4"></a><span style="color: #cc0000;">【<strong>三种刷新方式对缓存的区别</strong>】</span></h3>
<p align="left">众所周知浏览器是通过Last-Modified和Expires来处理缓存的，具体机制就不做解释，而在具体调试中发 现并不按我们想象的方式进行，其原因很有可能是在刷新浏览器的时候采用不恰当的方式导致。对于大多数浏览器而言，都包含有三种刷新方式，以下我们以IE浏 览器为例：</p>
<p align="left">F5 刷新<br /> Ctrl+F5 刷新<br /> &ldquo;转至&rdquo;或地址栏里回车 刷新</p>
<p align="left">这些快捷键的功能，主流浏览器都是相同的。<br /> 而这三种刷新方式会导致浏览器采取不同的缓存机制：</p>
<p align="left">F5：不允许浏览器直接使用本地缓存，因此Last-Modified能起作用，但Expires无效<br /> Ctrl+F5：是强制刷新，因此缓存机制失效<br /> &ldquo;转至&rdquo;或地址栏里回车：正常的访问，Last-Modified和Expires都有效</p>
<p align="left">知道浏览器刷新还有这么一回事后，那么以后在项目调试的过程中就不会感到疑惑了。</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<h2><a name="t5"></a><span style="color: #cc0000;">【参考资料】</span></h2>
<p align="left"><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a></p>
                    </div>
                    <div class="prenext">
                        <ul>
                            <li>上一篇：
                            
                                
                                   <a href="/article/39/">Emit之旅（二）-完整类展示</a></li>
                                
                            
                            <li>下一篇：
                            

                                
                               <a href="/article/41/">变态IE6的float</a></li>
                                
                            















                        </ul>
                    </div>
                    <div class="relatearticle">
                        <fieldset>
                            <legend>相关文章</legend>
                            <ul>
                                
                            </ul>
                        </fieldset>
                    </div>
            <a name="comment"></a>
                    <div class="area_title">评论列表</div>
                    <div class="commentlist">
                        

                    </div>
                    <div class="comment">
                        <a name="commenthref"></a>
                        <div class="commenterror" style="display: none;">出错啦！</div>
                        <div style="margin-bottom: 10px;">
                        <span>昵称：</span><input class="nickname" id="nickname"  name="nickname" value="guest" ><br>
                        </div>
                        <span>评论：</span><textarea class="com_content" id="commentcontent" name="commentcontent"   onblur="if(this.value=='') this.value=this.defaultValue;" onfocus="if(this.value==this.defaultValue) this.value='';" >必填，500字以内</textarea><br>
                        <div style="margin-top: 10px;text-align: center;">
                        <input type="button"  class="btnLogin" id="btnLogin" value="提交评论" >
                        </div>
                    </div>
        </div>
        <!-- end content -->
        <!-- start sidebar -->


    <div id="sidebar">
        <ul>
            <li>
                <h2>分类</h2>
                <ul>
                    
                        <li><a href="/category/3">随笔</a>(3)</li>
                    
                        <li><a href="/category/4">基础技术</a>(17)</li>
                    
                        <li><a href="/category/5">点滴记录</a>(20)</li>
                    
                        <li><a href="/category/8">网络摘抄</a>(12)</li>
                    
                        <li><a href="/category/9">读书笔记</a>(21)</li>
                    
                        <li><a href="/category/10">实例&amp;设计</a>(5)</li>
                    
                </ul>
            </li>
            <li>
                <h2>标签</h2>
                <ul>
                    
                        <li><a href="/tag/1">Javascript</a> (9)</li>
                    
                        <li><a href="/tag/2">C#</a> (19)</li>
                    
                        <li><a href="/tag/3">Linux</a> (2)</li>
                    
                        <li><a href="/tag/4">Django</a> (4)</li>
                    
                        <li><a href="/tag/5">SqlServer</a> (11)</li>
                    
                        <li><a href="/tag/6">Asp.net</a> (13)</li>
                    
                        <li><a href="/tag/7">闲扯</a> (2)</li>
                    
                        <li><a href="/tag/8">正则表达式</a> (1)</li>
                    
                        <li><a href="/tag/9">Python</a> (2)</li>
                    
                        <li><a href="/tag/10">Emit</a> (4)</li>
                    
                        <li><a href="/tag/11">Css</a> (1)</li>
                    
                        <li><a href="/tag/12">HTML</a> (1)</li>
                    
                        <li><a href="/tag/13">MongoDB</a> (5)</li>
                    
                        <li><a href="/tag/14">Redis</a> (2)</li>
                    
                        <li><a href="/tag/15">MVC</a> (1)</li>
                    
                </ul>
            </li>
            <!--<li>
                <h2>Archives</h2>
                <ul>
                    <li><a href="#">September</a> (23)</li>
                    <li><a href="#">August</a> (31)</li>
                    <li><a href="#">July</a> (31)</li>
                    <li><a href="#">June</a> (30)</li>
                    <li><a href="#">May</a> (31)</li>
                    <li><a href="#">April</a> (30)</li>
                    <li><a href="#">March</a> (31)</li>
                    <li><a href="#">February</a> (28)</li>
                    <li><a href="#">January</a> (31)</li>
                </ul>
            </li>-->
        </ul>
    </div>
</div>
<div style="clear: both; height: 30px">&nbsp;</div>
<!-- end page -->
<div id="footer">
    <p>&copy;2012  &nbsp;&bull;&nbsp; Designed by django<a href="http://www.izhunong.com" target="_blank">农产品</a><span class="tongji"><script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F97bd40f93c957f852fa3f663837bad9b' type='text/javascript'%3E%3C/script%3E"));
</script>
</span></p>
</div>

<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shCore.js' type="text/javascript"></script>
<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shBrushCSharp.js' type="text/javascript"></script>
<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shBrushCss.js' type="text/javascript"></script>
<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shBrushJava.js' type="text/javascript"></script>
<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shBrushJScript.js' type="text/javascript"></script>
<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shBrushPython.js' type="text/javascript"></script>
<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shBrushSql.js' type="text/javascript"></script>
<script src='http://static.guojl.com/js/syntaxhighligher/scripts/shBrushXml.js' type="text/javascript"></script>

<script type='text/javascript'>
    SyntaxHighlighter.all()

    function replay(layid){
        $('#commentcontent').val(layid+"#\r\n");
        $("html,body").animate({ scrollTop: $("a[name='commenthref']").offset().top }, 500);
    }

    $(document).ready(function(){
        //评论操作
        $('#commentcontent').blur(function(){
            var content=$('#commentcontent').val();
            if(content && content!=$('#commentcontent').attr('defaultValue')){
                $('.commenterror').hide();
            }
        })
        //图片缩放
        $(".maincontent img").each(function(i,el){
            var basewidth=$(".maincontent").width();
            var imgwidth=$(el).width();
            var imgheight=$(el).height();
            if(imgwidth>basewidth){
                $(el).attr("title","点击查看大图").css("cursor","pointer").click(function(){
                    window.open($(el).attr("src"));
                });
                imgheight=basewidth/imgwidth*imgheight;
                imgwidth=basewidth;
                $(el).width(imgwidth);
                $(el).height(imgheight);
            }
        });
        //评论部分
        $('#btnLogin').click(function(){
            var content=$('#commentcontent').val();
            if(!content || content==$('#commentcontent').attr('defaultValue')){
                alert('请正确输入评论！');
                return;
            }
            $.ajax({
                url:'/comment/add/',
                type:'POST',
                data:'article=40&nickname='+encodeURIComponent($('#nickname').val())+'&commentcontent='+encodeURIComponent(content),
                dataType:'json',
                success:function(data){
                    if(data.iserror){
                        msg=data.msg.commentcontent;
                        $(".commenterror").text(msg)
                        $(".commenterror").show();
                    }
                    else{
                        document.location.reload();
                    }
                }
            })
        })
        //点击量统计部分
        $.ajax({
            url:'/hit/40',
            type:"GET"
        })
    })
</script>


<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=slide&amp;img=0&amp;pos=right&amp;uid=809479" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
</script>
<!-- Baidu Button END -->
</body>
</html>
