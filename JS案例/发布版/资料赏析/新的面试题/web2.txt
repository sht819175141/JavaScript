1.iframe：在一个页面里去嵌套另一个页面。
1.<iframe>优点：

  可以很容易的把另一个页面的内容抓取过来。

2.<iframe>的缺点：
    *i不利于搜索引擎；
    *增加http请求
  
2.如何实现浏览器内多个便签页之间的通信？

  localstorage ,cookie 本地存储。


3，如果需要手动写动画，你认为最小时间间隔是多少？
答：多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms

4，display:inline-block什么时候会显示间隙？
答：元素之间如果打了回车或者空格，那么就会出现间距

5、使用闭包完成一个简单的计数器
function jishuqi(){
            var i=0;
            return function(){
                return i++;
            }
        }
        var s=jishuqi();
        s();
        s();
eval是做什么的？

它的功能是把对应的字符串解析成JS代码并运行；
应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
js延迟加载（异步加载）的方式有哪些？

defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js

css hack
简单地讲，css hack指各版本及各品牌浏览器之间对CSS解释后出现网页内容的误差(比如我们常说错位)的处理。由于各浏览器的内核不同，所以会造成一些误差就像JS一样，一个JS网页特效，在微软IE6、IE7、IE8浏览器有效果，但可能在火狐（Mozilla Firefox）谷歌浏览器无效，这样就叫做JS hack ，所以我们对于CSS来说他们来解决各浏览器对CSS解释不同所采取的区别不同浏览器制作不同的CSS样式的设置来解决这些问题就叫作CSS Hack。
什么是CSS hack
由于不同厂商的浏览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!

CSS hack的原理
由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。

CSS hack分类
CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。

属性前缀法(即类内部Hack)：例如 IE6能识别下划线"_"，IE7能识别星号" * "，但不能识别下划线"_"，IE6~IE10都认识"\9"，但firefox前述三个都不能认识。
选择器前缀法(即选择器Hack)：例如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。
IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： ，针对IE6及以下版本： 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。
　　
CSS hack书写顺序，一般是将适用范围广、被识别能力强的CSS定义在前面。

CSS hack方式一：条件注释法
　
这种方式是IE浏览器专有的Hack方式，微软官方推荐使用的hack方式。举例如下

	只在IE下生效
	
	
	只在IE6下生效
	
	
	只在IE6以上版本生效
	
	
	只在IE8上不生效
	
	
	非IE浏览器生效
	
CSS hack方式二：类内属性前缀法
属性前缀法是在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果。

IE浏览器各版本 CSS hack 对照表

hack	写法	实例	IE6(S)	IE6(Q)	IE7(S)	IE7(Q)	IE8(S)	IE8(Q)	IE9(S)	IE9(Q)	IE10(S)	IE10(Q)
*	*color	青色	Y	Y	Y	Y	N	Y	N	Y	N	Y
+	+color	绿色	Y	Y	Y	Y	N	Y	N	Y	N	Y
-	-color	黄色	Y	Y	N	N	N	N	N	N	N	N
_	_color	蓝色	Y	Y	N	Y	N	Y	N	Y	N	N
#	#color	紫色	Y	Y	Y	Y	N	Y	N	Y	N	Y
\0	color:red\0	红色	N	N	N	N	Y	N	Y	N	Y	N
\9\0	color:red\9\0	粉色	N	N	N	N	N	N	Y	N	Y	N
!important	color:blue !important;color:green;	棕色	N	N	Y	N	Y	N	Y	N	Y	Y
说明：在标准模式中

“-″减号是IE6专有的hack
“\9″ IE6/IE7/IE8/IE9/IE10都生效
“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack
“\9\0″ 只对IE9/IE10生效，是IE9/10的hack
demo如下

[css] view plaincopy
  
demo1是测试不同IE浏览器下hack 的显示效果
IE6显示为：粉色，
IE7显示为：粉色，
IE8显示为：蓝色，
IE9显示为：蓝色，
Firefox/Chrome/Opera显示为：蓝色，
若去掉其中的!important属性定义，则IE6/7仍然是粉色，IE8是紫色，IE9/10为橙色，Firefox/Chrome变为红色，Opera是紫色。是不是有些奇怪：除了IE6以外，其他所有的表现都符合我们的期待。那为何IE6表现的颜色不是_background-color:green;的绿色而是*+background-color:pink的粉色呢？其实是最后一句所谓的IE7私有hack惹的祸？不是说*+是IE7的专有hack吗？？？错，你可能太粗心了！我们常说的IE7专有*+hack的格式是*+html selector，而不是上面的直接在属性上加*+前缀。如果是为IE7定制特殊样式，应该这样使用：

*+html #ie7test { /* IE7 only*/
	color:green;
}
经过测试，我发现属性前缀*+background-color:pink;只有IE6和IE7认识。而*+html selector只有IE7认识。所以我们在使用时候一定要特别注意。

demo2实例是用于区分标准模式下ie6~ie9和Firefox/Chrome的hack，注意顺序
IE6显示为：绿色，
IE7显示为：黑色，
IE8显示为：红色，
IE9显示为：蓝色，
Firefox/Chrome显示为：橘色，
（本例IE10效果同IE9,Opera最新版效果同IE8）

demo3实例也是用于区分标准模式下ie6~ie9和Firefox/Chrome的hack，注意顺序
IE6显示为：红色，
IE7显示为：蓝色，
IE8显示为：绿色，
IE9显示为：粉色，
Firefox/Chrome显示为：橘色，
（本例IE10效果同IE9，Opera最新版效果也同IE9为粉色）

demo4实例是用于区分标准模式下ie6~ie10和Opera/Firefox/Chrome的hack，本例特别要注意顺序
IE6显示为：橘色，
IE7显示为：粉色，
IE8显示为：黄色，
IE9显示为：紫色，
IE10显示为：绿色，
Firefox显示为：蓝色，
Opera显示为：黑色，
Safari/Chrome显示为：灰色，


CSS hack方式三：选择器前缀法
选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。

目前最常见的是

*html *前缀只对IE6生效
*+html *+前缀只对IE7生效
@media screen\9{...}只对IE6/7生效
@media \0screen {body { background: red; }}只对IE8有效
@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效
@media screen\0 {body { background: green; }} 只对IE8/9/10有效
@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效
等等
结合CSS3的一些选择器，如html:first-child，body:nth-of-type(1)，衍生出更多的hack方式，具体的可以参考下表：


CSS3选择器结合JavaScript的Hack
我们用IE10进行举例：

由于IE10用户代理字符串（UserAgent）为：Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)，所以我们可以使用javascript将此属性添加到文档标签中，再运用CSS3基本选择器匹配。

JavaScript代码:

	var htmlObj = document.documentElement;
	htmlObj.setAttribute('data-useragent',navigator.userAgent);
	htmlObj.setAt 

如何通过javascript对象中的成员变量迭代


//jQuery 里面有一个方法 ezch 可以对对象进行遍历
 
var obj = {"id" : 1 ,"name" : "zs"},
$.each(obj,function(index,value){
    console.debug(index,value);
})
//或者使用这个
for(var p in obj){
    console.debug(obj[p])
}

跨域：
 页面与页面不同源的情况下需要跨域。
跨域如何产生的？
    协议不同或者端口不同或者域名不同都需要跨域。


2.<!DOCTYPE>标签的定义与用法
<!DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告

知浏览器文档使用哪种 HTML 或 XHTML 规范。

该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文

档。

3.列举css盒子模型的属性
content (内容)、padding (间隙)、border(边框)、margin(间隔)

10.__proto__是什么，请介绍一下？
  __proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，__proto__是对象的内置属性），是JS内部使用寻找原型链的属性。
用c 和FF都可以访问到对象的__proto__属性，IE不可以。

11.css hack的技巧
针对不同的浏览器写不同的CSS code的过程，就叫CSS hack，也叫写CSS hack。
比如 IE6能识别下划线“_”和星号“ * ”，IE7能识别星号“ * ”，但不能识别下划线“_”，而firefox两个都不能认识。
书写顺序，一般是将识别能力强的浏览器的CSS写在后面。
1：!important
!important作用是提高指定样式规则的应用优先权。
IE7以及所有标准浏览器能识别!important      区别IE6与IE7与其他浏览器
.browserTest 
{ 
    border:20px solid #60A179 !important;  //  非IE6
    border:20px solid #00F;   //  IE6
}
2：*
IE都能识别*；标准浏览器（如火狐）不能识别*    区别IE6与火狐
.browserTest 
{ 
    border:20px solid #60A179;  //  火狐
    *border:20px solid #00F;       //  IE
} 
3：_
IE6支持下划线，IE7和firefox均不支持下划线     区别IE7，IE6与火狐
.browserTest 
{ 
   border:20px solid #60A179;  //  火狐
   *border:20px solid #00F;       //  IE7
   _border:20px solid ###;        //  IE6
}
/*不管是什么方法，书写的顺序都是firefox的写在前面，IE7的写在中间，IE6的写在最后面*/


前端优化:
[内容]尽量减少HTTP请求数b 
[服务器]使用CDN（Content Delivery Network）
[服务器]添上Expires或者Cache-Control HTTP头
[服务器]Gzip组件
[css]把样式表放在顶部
[js]把脚本放在底部
[css]避免使用CSS表达式
[js, css]把JavaScript和CSS放到外面
[内容]减少DNS查找
[js, css]压缩JavaScript和CSS
[内容]避免重定向
[js]去除重复脚本
[服务器]配置ETags
[内容]让Ajax可缓存
[服务器]尽早清空缓冲区
[服务器]对Ajax用GET请求
[内容]延迟加载组件
[内容]预加载组件
[内容]减少DOM元素的数量
[内容]跨域分离组件
[内容]尽量少用iframe
[内容]杜绝404
[cookie]给Cookie减肥
[cookie]把组件放在不含cookie的域下
[js]尽量减少DOM访问
[js]用智能的事件处理器
[css]选择舍弃@import
[css]避免使用滤镜
[图片]优化图片
[图片]优化CSS Sprite
[图片]不要用HTML缩放图片
[图片]用小的可缓存的favicon.ico（P.S. 收藏夹图标）
[移动端]保证所有组件都小于25K
[移动端]把组件打包到一个复合文档里
[服务器]避免图片src属性为空

5.浏览器渲染引擎，js引擎都知道哪些：
渲染引擎：
　　　　Firefox使用gecko引擎
　　　　IE使用Trident引擎
　　　　chrome\safari\opera使用webkit引擎
　　　　13年chrome和safari开始使用Blink引擎
　　js引擎：
　　　　老版本IE使用Jscript引擎
　　　　IE9之后使用Chakra引擎
　　　　firefox使用monkey系列引擎
　　　　chrome使用V8引擎。nodeJs其实就是封装了V8引擎

内存泄漏

 编辑
[1]  内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。
1: 基本的循环引用模型
 2. 闭包函数引起的循环引用
3. DOM插入顺序泄漏模型



如何会造成内存的泄露？ 
就答：闭包会造成内存的泄露；
内存泄漏指：任何对象在您不再拥有或需要它之后仍然存在。 
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 
例举造成内存泄露的例子
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）

什么是柯里化？什么是反柯里化？他们的区别是什么？
柯里化：是函数编程的里的函数作为函数的返回值，



link,:visited,:focus,:hover,:active详解
CSS 又名 层叠样式表，所谓层叠，就是后面的样式会覆盖前面的样式，所以在样式表中，各样式排列的顺序很有讲究。
:link 与 :visited 在样式文件中的顺序可以随便放置。
而focus， hover，active这几个，如果你设置的顺序不同，会直接影响样式的显示效果，下面会详细解释。
:focus -> :hover -> :active
有些人可能会困惑，为什么必须要按这样的顺序，而不能打乱呢？ 其实他们每一个选择器都代表一个含义。
:link代表为访问链接的样式，所以只要你是超链接，且未被访问过，则链接都会按照你设定的样式显示，所以它的位置顺序无所谓。
:visited代表链接访问后的样式，则链接一旦被访问，则之后它的样式就会是你所设置的visited样式
重点是下面这几个：
:focus 代表的是获取焦点时的样式，有人说啥是获取焦点时的样式，这个我们可以通过tab键来查看，一旦链接获取了焦点，则它的样式就是你设置的focus样式
:hover 代表的是你光标经过某一元素时的样式，如果将此样式放在:focus之后，则当链接获取焦点时，显示:focus样式，当光标经过此链接时，会显示hover的样式，因为hover排在后，会覆盖focus样式。
如果:hover排在前，:focus排在后，则当光标获得焦点时显示:focus的样式，但当光标经过链接时，样式并未显示:hover的样式，而是继续是:focus的样式，因为应用的focus样式在hover之后，覆盖了前面的样式。
link >visited >focus >hover  >active
为您疯狂
dom ready事件与window.onload事件

window.onload事件，是在页面所有的资源都加载完毕后触发的. 如果页面上有大图片等资源响应缓慢, 会导致window.onload事件迟迟无法触发.所以出现了DOM Ready事件. 

此事件，在DOM文档结构准备完毕后触发, 即在资源加载前触发. 

另外，我们需要在DOM准备完毕后, 再修改DOM结构, 比如添加DOM元素等. 否则有可能出现“Internet Explorer无法打开站点”的问题.

对于FF, Chrome, Safari, IE9等浏览器:
DOMContentLoaded 事件在许多Webkit浏览器以及IE9上都可以使用, 此事件会在DOM文档准备好以后触发, 包含在HTML5标准中. 对于支持此事件的浏览器, 直接使用DOMContentLoaded事件是最简单最好的选择.
对于IE6,7,8:
不幸的是, IE6,7,8都不支持DOMContentLoaded事件.
所以，目前所有的hack方法，都是为了让IE6,7,8支持DOM Ready事件.

// for Mozilla browsers
if (document.addEventListener) {
	document.addEventListener("DOMContentLoaded", init, false);
}

// for Internet Explorer
<!--[if IE]><script defer src="http://jiataodong.blog.163.com/ie_onload.js"></script><![endif]-->
或者
/*@cc_on @*/
/*@if (@_win32)
	document.write("<script defer src=ie_onload.js><\/script>");
/*@end @*/

// for other browsers
window.onload = init;

// for Internet Explorer (using conditional comments)
/*@cc_on @*/
/*@if (@_win32)
document.write("<script id=__ie_onload defer src=javascript:void(0)><\/script>");
  var script = document.getElementById("__ie_onload");
  script.onreadystatechange = function() {
	if (this.readyState == "complete") {
		init(); // call the onload handler
	}
  };
/*@end @*/

// for Safari!
if (/WebKit/i.test(navigator.userAgent)) { // sniff
	var _timer = setInterval(function() {
		if (/loaded|complete/.test(document.readyState)) {
			clearInterval(_timer);
			init(); // call the onload handler
		}
	}, 10);
}
(1)setTimeout : 在setTimeout中触发的函数, 一定会在DOM准备完毕后触发.

(2)readyState: 判断readyState的状态是否为Complete, interactive等触发

(3)doScroll : 微软的文档指出，doScroll必须在DOM主文档准备完毕时，才可以正常触发. 所以通过doScroll判断DOM是否准备完毕.

结论.
setTimeout设置的函数, 会在readyState为complete时触发, 但是触发时间点，是在图片资源加载完毕后.
readyState为interactive时, DOM结构并没有稳定, 此时依然会有脚本修改DOM元素.
readyState为complete时, 图片已经加载完毕, 对图片加载设置了延时.。所以complete虽然在window.onload前执行, 但是还是太晚.
外部script:如果将此script放在页面上方, 则无法稳定触发. 并且触发时DOM结构依然可能发生变化.
内部script:与外部script同样的问题, 触发的时间过早.
doScroll: doScroll通过时，readyState可能为interactive, 也可能为complete. 但是一定会在DOM结构稳定后, 图片加载完毕前执行.
所以可以看出, 目前的setTimeout方法, 外部script和内部script方法, 都是存在错误的.应该说这些方法，都不能安全可靠的实现DomReady事件.
而单纯使用readyState属性，是无法判断出Dom Ready事件的. interactive状态过早(DOM没有稳定), complete状态过晚(图片加载完毕).
DOM Ready实现代码

/**        Dom Ready Event        */
            ready : function( callback , delay, win){
                win = win || this.win || window;
                var doc = win.document;
                delay = delay || 0;
                this.domReadyMonitorRunTimes = 0;          
                //将时间函数放入数组, 在DomReady时一起执行.this.readyFuncArray = this.readyFuncArray || [];
                this.readyFuncArray.push({func:callback, delay:delay, done:false});    
//domReadyMonitor为监控进程的事件处理函数var domReadyMonitor = (function(){
                    var isReady = false;
                    this.domReadyMonitorRunTimes++;                  
                    //对于非iframe嵌套的ie6,7,8浏览器, 使用doScroll判断Dom Ready.if(this.browser.ie && this.browser.ie<9 && !win.frameElement){
                        try {
                            doc.documentElement.doScroll("left");
                            isReady = true;
                        } 
                        catch(e) {
                        }
                    }
                    //非ie浏览器//如果window.onload和DOMContentLoaded事件都绑定失败, 
                    //则使用定时器函数判断readyState.                elseif(doc.readyState==="complete" || this.domContentLoaded ){
                            isReady = true;
                    }
                    //对于某些特殊页面, 如果readyState永远不能为complete, 
                    //设置了一个最大运行时间5分钟. 超过了最大运行时间则销毁定时器.//定时器销毁不影响window.onload和DOMContentLoaded事件的触发.else{
                        if(this.domReadyMonitorRunTimes > 300000){
                            if(this.domReadyMonitorId){
                                win.clearInterval(this.domReadyMonitorId);
                                this.domReadyMonitorId = null;
                           }
                           return;
                        }
                    }               
                   //执行ready集合中的所有函数if(isReady){
                        try{
                            if(this.readyFuncArray && this.readyFuncArray.length){
                                for(var i=0, count=this.readyFuncArray.length; i<count; i++){
                                    var item = this.readyFuncArray[i];
                                    if(!item || !item.func || item.done){
                                        continue;
                                    }                                  
                                    if(!item.delay){    
                                        item.done = true;
                                        item.func();
                                    }
                                    else{
                                        item.done = true;
                                        win.setTimeout(item.func, item.delay);
                                    }
                                }
                            }
                        }
                        catch(ex){
                            throw ex;
                        }
                        finally{
                            if(this.domReadyMonitorId){
                                win.clearInterval(this.domReadyMonitorId);
                                this.domReadyMonitorId = null;
                            }
                        }
                   }
                }).__proxy(this);          
                /**            domContentLoadedHandler直接执行所有ready函数.            没使用传参的形式是因为ff中的定时器函数会传递一个时间参数.            */var domContentLoadedHandler = (function(){
                   this.domContentLoaded = true;
                    domReadyMonitor();
                }).__proxy(this);          
                //启动DomReady监控进程if(!this.domReadyMonitorStarted){
                    this.domReadyMonitorStarted = true;    
                    this.domReadyMonitorId = win.setInterval( domReadyMonitor, 50);
                    // Mozilla, Opera and webkit nightlies currently support this eventif ( doc.addEventListener ) {
                        // Use the handy event callback
                        doc.addEventListener( "DOMContentLoaded", domContentLoadedHandler, false );
                        // A fallback to window.onload, that will always work
                        win.addEventListener( "load", domContentLoadedHandler, false );                
                    }
                    elseif(doc.attachEvent){
                        // A fallback to window.onload, that will always work
                        win.attachEvent( "onload", domContentLoadedHandler, false ); 
                    }
                }           
            }

__proxy"函数代码如下:
//扩展function函数原型。
//为所有的function对象添加proxy函数，用于修改函数的上下文。
                Function.prototype.__proxy = function(context){
                    var method = this;
                    returnfunction () {
                         return method.apply(context || {}, arguments);
                    };
                }; 

